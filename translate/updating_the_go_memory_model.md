# Updating the Go Memory Model

当前的 Go 语言内存模型是在 2009 年编写的，此后进行了小幅更新。 很明显，至少有一些细节我们应该添加到当前的内存模型中，其中包括对竞争检测器的明确认可以及对同步/原子同步程序中的 API 如何进行的明确说明。

这篇文章重申了 Go 的整体理念和当前的内存模型，然后概述了我认为我们应该对 Go 内存模型进行的相对较小的调整。 它假设了之前文章“硬件内存模型”和“编程语言内存模型”中介绍的背景。

我打开了一个 GitHub 讨论来收集对这里提出的想法的反馈。 基于这些反馈，我打算在本月晚些时候准备一份正式的 Go 提案。 使用 GitHub 讨论本身就是一个实验，继续尝试找到一种合理的方式来扩大对重要变化的讨论。



## [Go's Design Philosophy](https://research.swtch.com/gomm#gos_design_philosophy)

Go 旨在成为构建实用、高效系统的编程环境。 它旨在为小型项目轻量级，但也可以优雅地扩展到大型项目和大型工程团队。

Go 鼓励在高层次上接近并发，特别是通过通信。  Go 的第一个谚语是“不要通过共享内存进行通信。 通过交流分享记忆。” 另一个流行的谚语是“清晰胜于聪明”。 换句话说，Go 鼓励通过避免微妙的代码来避免微妙的错误。

Go 的目标不仅是可理解的程序，而且是可理解的语言和可理解的包 API。 复杂或微妙的语言特性或 API 与该目标相矛盾。 正如托尼·霍尔在 1980 年图灵奖演讲中所说:  [1980 Turing award lecture](https://www.cs.fsu.edu/~engelen/courses/COP4610/hoare.pdf):

​	我的结论是，有两种构建软件设计的方法：一种方法是让它简单到没有*明显*缺陷，另一种方法是使它复杂到没有*明显*缺陷。

​    第一种方法要困难得多。 它需要与发现构成复杂自然现象的简单物理定律相同的技能、奉献精神、洞察力甚至灵感。 它还需要愿意接受受到物理、逻辑和技术	约束的目标，并在无法满足相互冲突的目标时接受妥协。

这与 Go 的 API 哲学非常吻合。 我们通常会在设计过程中花费很长时间来确保 API 是正确的，并努力将其减少到最小、最有用的本质。



Go 作为一个有用的编程环境的另一个方面是对最常见的编程错误具有明确定义的语义，这有助于理解和调试。 这个想法并不新鲜。 再次引用 Tony Hoare 的话，这一次来自他 1972 年的“[软件质量](https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380020202)”清单:

​		使用起来非常简单外，软件程序还必须很难被误用； 它必须善待编程错误，清楚地表明它们的发生，并且永远不会变得不可预测。



