# Updating the Go Memory Model

当前的 Go 语言内存模型是在 2009 年编写的，此后进行了小幅更新。 很明显，至少有一些细节我们应该添加到当前的内存模型中，其中包括对竞争检测器的明确认可以及对同步/原子同步程序中的 API 如何进行的明确说明。

这篇文章重申了 Go 的整体理念和当前的内存模型，然后概述了我认为我们应该对 Go 内存模型进行的相对较小的调整。 它假设了之前文章“硬件内存模型”和“编程语言内存模型”中介绍的背景。

我打开了一个 GitHub 讨论来收集对这里提出的想法的反馈。 基于这些反馈，我打算在本月晚些时候准备一份正式的 Go 提案。 使用 GitHub 讨论本身就是一个实验，继续尝试找到一种合理的方式来扩大对重要变化的讨论。



## [Go's Design Philosophy](https://research.swtch.com/gomm#gos_design_philosophy)

Go 旨在成为构建实用、高效系统的编程环境。 它旨在为小型项目轻量级，但也可以优雅地扩展到大型项目和大型工程团队。

Go 鼓励在高层次上接近并发，特别是通过通信。  Go 的第一个谚语是“不要通过共享内存进行通信。 通过交流分享记忆。” 另一个流行的谚语是“清晰胜于聪明”。 换句话说，Go 鼓励通过避免微妙的代码来避免微妙的错误。

Go 的目标不仅是可理解的程序，而且是可理解的语言和可理解的包 API。 复杂或微妙的语言特性或 API 与该目标相矛盾。 正如托尼·霍尔在 1980 年图灵奖演讲中所说:  [1980 Turing award lecture](https://www.cs.fsu.edu/~engelen/courses/COP4610/hoare.pdf):

​	我的结论是，有两种构建软件设计的方法：一种方法是让它简单到没有*明显*缺陷，另一种方法是使它复杂到没有*明显*缺陷。

​    第一种方法要困难得多。 它需要与发现构成复杂自然现象的简单物理定律相同的技能、奉献精神、洞察力甚至灵感。 它还需要愿意接受受到物理、逻辑和技术	约束的目标，并在无法满足相互冲突的目标时接受妥协。

这与 Go 的 API 哲学非常吻合。 我们通常会在设计过程中花费很长时间来确保 API 是正确的，并努力将其减少到最小、最有用的本质。



Go 作为一个有用的编程环境的另一个方面是对最常见的编程错误具有明确定义的语义，这有助于理解和调试。 这个想法并不新鲜。 再次引用 Tony Hoare 的话，这一次来自他 1972 年的“[软件质量](https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380020202)”清单:

​		使用起来非常简单外，软件程序还必须很难被误用； 它必须善待编程错误，清楚地表明它们的发生，并且永远不会变得不可预测。

为有缺陷的程序定义明确语义的常识并不像人们想象的那样普遍。 在 C/C++ 中，未定义的行为已经演变成一种编译器作者的全权委托，以更加有趣的方式将稍微有错误的程序变成非常不同的有错误的程序。  Go 没有采用这种方法：没有“未定义的行为”。 特别是，空指针解引用、整数溢出和无意的无限循环等错误都在 Go 中定义了语义。



## [Go's Memory Model Today](https://research.swtch.com/gomm#gos_memory_model_today)



Go 的内存模型从以下建议开始，与 Go 的整体理念一致：

​	修改多个 goroutine 同时访问的数据的程序必须序列化这种访问。
​    要序列化访问，请使用通道操作或其他同步原语（例如 sync 和 sync/atomic 包中的原语）保护数据。
​    如果您必须阅读本文档的其余部分才能了解您的程序的行为，那么您就太聪明了。
​    不要聪明。

这仍然是很好的建议。 该建议也与其他语言对 DRF-SC 的鼓励一致：同步以消除数据竞争，然后程序将表现得好像顺序一致，无需了解内存模型的其余部分。

在这个建议之后，Go 内存模型定义了一个传统的基于之前发生的读取和写入的定义。 就像在 Java 和 JavaScript 中一样，Go 中的读取可以观察任何较早但尚未覆盖的写入，或者任何竞速写入； 安排只有一个这样的写入强制特定的结果。



然后，内存模型继续定义建立跨协程发生前边缘的同步操作。 操作是通常的操作，带有一些 Go 特定的风味：

​	如果包 p 导入包 q，则 q 的 init 函数的完成发生在任何 p 的开始之前。

​	main.main 函数的启动发生在所有 init 函数完成之后。

​	启动新 goroutine 的 go 语句发生在 goroutine 开始执行之前。

​	通道上的发送发生在来自该通道的相应接收完成之前。

​	通道的关闭发生在由于通道关闭而返回零值的接收之前。

​	来自无缓冲通道的接收发生在该通道上的发送完成之前。

​	容量为 C 的通道上的第 k 个接收发生在来自该通道的第 k+C 个发送完成之前。

​	对于任何sync.Mutex 或sync.RWMutex 变量l 且n < m，l.Unlock() 的n 调用发生在l.Lock() 的调用m 返回之前。

​	从 once.Do(f) 对 f() 的单个调用发生（返回）在任何对 once.Do(f) 的调用返回之前。

该列表明显省略了同步/原子以及包同步中更新的 API 的任何提及。

内存模型以一些不正确同步的例子结束。 它不包含错误编译的示例。

## [Changes to Go's Memory Model](https://research.swtch.com/gomm#changes_to_gos_memory_model)

2009 年，在我们着手编写 Go 的内存模型时，Java 内存模型进行了新的修订，C/C++11 内存模型正在最终确定。 一些人强烈鼓励我们采用 C/C++11 模型，充分利用其中的所有工作。 这对我们来说似乎很冒险。 取而代之的是，我们决定采用更保守的方法来保证我们将做出的保证，随后十年的论文证实了这一决定，这些论文详细介绍了 Java/C/C++ 内存模型系列中非常微妙的问题。 定义足够多的内存模型来指导程序员和编译器作者很重要，但是完全正式地定义一个模型——正确！——似乎仍然超出了最有才华的研究人员的掌握范围。  Go 继续说明有用的最低要求就足够了。

本节列出了我认为我们应该做出的调整。 如前所述，我打开了一个 GitHub 讨论来收集反馈。 基于这些反馈，我计划在本月晚些时候准备一份正式的 Go 提案。

### [Document Go's overall approach](https://research.swtch.com/gomm#document_gos_overall_approach)

自编写内存模型以来，新的 API 已添加到同步包中。 我们需要将它们添加到内存模型中（issue #7948）。 值得庆幸的是，这些添加看起来很简单。 我相信它们如下。

​	对于sync.Cond：广播或信号发生在它解除阻塞的任何等待调用返回之前。
​    对于sync.Map：Load、LoadAndDelete 和LoadOrStore 是读取操作。  Delete、LoadAndDelete 和 Store 是写操作。  LoadOrStore 是一个写操作，当它返回加载设置为 false 时。 写入操作发生在任何观察写入效果的读取操作之前。
​    对于sync.Pool：在调用Get 之前调用Put(x) 会返回相同的值x。 类似地，调用 New 返回 x 发生在调用 Get 返回相同值 x 之前。
​    对于sync.WaitGroup：在它解除阻塞的任何Wait 调用返回之前，会调用Done。

这些 API 的用户需要了解这些保证才能有效地使用它们。 因此，虽然我们应该将文本保留在内存模型中以进行说明，但我们也应该将其包含在包同步的文档注释中。 这也将有助于为第三方同步原语树立一个例子，说明记录 API 建立的排序保证的重要性。



### [Document happens-before for sync/atomic](https://research.swtch.com/gomm#document_happens-before_for_sync/atomic)

内存模型中缺少原子操作。 我们需要添加它们（问题 #5045）。 我相信我们应该说：

​	sync/atomic 包中的 API 统称为“原子操作”，可用于同步不同 goroutine 的执行。 如果原子操作 B 观察到原子操作 A 的效果，则 A 发生在 B 之前。程序中执行的所有原子操作的行为就像以某种顺序一致的顺序执行一样。

这是 [Dmitri Vyukov 在 2013 年提出的建议](https://github.com/golang/go/issues/5045#issuecomment-66076297) 和 [我在 2016 年非正式的承诺](https://github.com/golang  /go/issues/5045#issuecomment-252730563）。 它还具有与 Java 的 `volatile` 和 C++ 的默认原子相同的语义。

在 C/C++ 菜单方面，同步原子只有两种选择：顺序一致或获取/释放。  （宽松的原子不会创建发生在边缘之前，因此没有同步效果。）这些之间的决定归结为，首先，能够推理多个位置上原子操作的相对顺序有多重要，以及， 其次，与获取/释放原子相比，顺序一致原子要贵多少。

首先，推理多个位置上原子操作的相对顺序非常重要。 在之前的一篇博文中，我给出了一个条件变量的示例，其中包含使用两个原子变量实现的无锁快速路径，通过使用获取/释放原子来破坏。 这种模式一次又一次地出现。 例如，sync.WaitGroup 的过去实现使用了一对原子 uint32 值 wg.counter 和 wg.waiters。 信号量的 Go 运行时实现也依赖于两个独立的原子词，即信号量值 *addr 和对应的等待计数 root.nwait。 还有更多。 在没有顺序一致语义的情况下（即如果我们改用获取/释放语义），人们仍然会写这样的代码； 它只会在某些情况下神秘地失败。

根本问题是，使用获取/释放原子使程序无数据竞争并不会导致程序以顺序一致的方式运行，因为原子本身不会。 也就是说，此类程序不提供 DRF-SC。 这使得此类程序很难推理，因此很难正确编写。

在第二个考虑因素中，如前文所述，硬件设计人员开始为顺序一致的原子提供直接支持。 例如，ARMv8 增加了 ldar 和 stlr 指令用于实现顺序一致的原子，它们也是获取/释放原子的推荐实现。 如果我们为同步/原子采用获取/释放语义，那么在 ARMv8 上编写的程序无论如何都会获得顺序一致性。 这无疑会导致程序意外地依赖于较强的排序，从而在较弱的平台上崩溃。 如果在实践中由于竞争窗口很小而难以观察到获取/释放和顺序一致原子之间的差异，这甚至可能发生在单个架构上。
