## 浏览器从输入url到页面显示经过了哪些步骤
浏览器从输入URL到页面显示的过程涉及多个步骤，通常称为“浏览器渲染流程”或“页面加载流程”。以下是详细步骤：

---

### 1. **输入URL并解析**
   - 用户在浏览器地址栏输入URL（如 `https://www.example.com`）。
   - 浏览器解析URL，提取协议（如 `https`）、域名（如 `www.example.com`）和路径（如 `/index.html`）。

---

### 2. **DNS解析**
   - 浏览器检查本地缓存（如浏览器缓存、操作系统缓存）中是否有域名的IP地址。
   - 如果缓存中没有，浏览器会向DNS服务器发起请求，解析域名对应的IP地址。
   - DNS解析过程：
     1. 查询本地DNS缓存。
     2. 向配置的DNS服务器（如ISP的DNS服务器）发起请求。
     3. 如果DNS服务器没有缓存，会递归查询根域名服务器、顶级域名服务器（如 `.com`）和权威域名服务器，最终获取IP地址。

---

### 3. **建立TCP连接**
   - 浏览器通过IP地址和端口（默认HTTP是80，HTTPS是443）与服务器建立TCP连接。
   - 如果是HTTPS，还会进行TLS/SSL握手，建立加密通道。
   - **三次握手**：
     1. 客户端发送SYN包到服务器。
     2. 服务器回复SYN-ACK包。
     3. 客户端发送ACK包，连接建立。

---

### 4. **发送HTTP请求**
   - 浏览器向服务器发送HTTP请求，请求内容包括：
     - 请求方法（如 `GET`、`POST`）。
     - 请求路径（如 `/index.html`）。
     - 请求头（如 `Host`、`User-Agent`、`Accept`）。
     - 如果是POST请求，还会包含请求体（如表单数据）。

---

### 5. **服务器处理请求**
   - 服务器接收到请求后，根据请求路径和方法处理请求。
   - 服务器可能执行以下操作：
     - 读取静态文件（如HTML、CSS、JS）。
     - 调用后端逻辑（如查询数据库、处理业务逻辑）。
     - 生成动态内容（如通过PHP、Node.js等）。
   - 服务器返回HTTP响应，包括：
     - 状态码（如 `200 OK`、`404 Not Found`）。
     - 响应头（如 `Content-Type`、`Content-Length`）。
     - 响应体（如HTML文件内容）。

---

### 6. **浏览器接收响应**
   - 浏览器接收到服务器的HTTP响应。
   - 根据响应头中的 `Content-Type` 判断资源类型（如 `text/html`、`application/json`）。

---

### 7. **解析HTML并构建DOM树**
   - 浏览器解析HTML文件，将其转换为DOM（Document Object Model）树。
   - 解析过程：
     1. 将HTML字符串转换为Token。
     2. 根据Token构建DOM节点。
     3. 将节点组织成树形结构（DOM树）。

---

### 8. **加载子资源（CSS、JS、图片等）**
   - 浏览器解析HTML时，遇到外部资源（如 `<link>`、`<script>`、`<img>`）会发起额外的HTTP请求。
   - 加载CSS文件并解析，构建CSSOM（CSS Object Model）树。
   - 加载JavaScript文件并执行（可能会阻塞DOM构建）。

---

### 9. **构建渲染树（Render Tree）**
   - 浏览器将DOM树和CSSOM树合并，生成渲染树（Render Tree）。
   - 渲染树只包含需要显示的节点（如排除 `display: none` 的元素）。

---

### 10. **布局（Layout）**
   - 浏览器计算渲染树中每个节点的几何信息（如位置、大小）。
   - 这一过程也称为“重排”（Reflow）。

---

### 11. **绘制（Paint）**
   - 浏览器将渲染树中的每个节点绘制到屏幕上。
   - 这一过程包括将文本、颜色、边框等渲染为像素。

---

### 12. **显示页面**
   - 最终，浏览器将绘制的内容显示在屏幕上，用户可以看到页面。

---

### 额外步骤：JavaScript执行与异步加载
   - 如果页面中包含JavaScript代码，浏览器会执行这些代码。
   - JavaScript可能会修改DOM或CSSOM，触发重新布局和绘制。
   - 异步加载的资源（如图片、AJAX请求）可能会在页面显示后继续加载。

---

### 总结
从输入URL到页面显示的主要步骤：
1. 输入URL并解析。
2. DNS解析。
3. 建立TCP连接（HTTPS还包括TLS握手）。
4. 发送HTTP请求。
5. 服务器处理请求并返回响应。
6. 浏览器解析HTML，构建DOM树。
7. 加载子资源（CSS、JS、图片等）。
8. 构建渲染树。
9. 布局（计算几何信息）。
10. 绘制（渲染像素）。
11. 显示页面。

这个过程涉及网络、浏览器引擎、渲染引擎等多个组件的协作，优化每个步骤可以提升页面加载性能。

## http协议
HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。它是万维网（WWW）数据通信的基础，主要用于在客户端（如浏览器）和服务器之间传输超文本（如HTML）和其他资源。

### HTTP 的主要特点
1. **无状态**：HTTP 是无状态协议，意味着每个请求都是独立的，服务器不会保留之前请求的信息。
2. **请求-响应模型**：客户端发送请求，服务器返回响应。
3. **支持多种方法**：如 GET、POST、PUT、DELETE 等。
4. **可扩展**：通过头部字段和状态码，HTTP 可以支持各种功能扩展。

### HTTP 请求方法
- **GET**：请求指定资源。
- **POST**：向指定资源提交数据。
- **PUT**：更新指定资源。
- **DELETE**：删除指定资源。
- **HEAD**：获取资源的元信息。
- **OPTIONS**：获取服务器支持的HTTP方法。
- **PATCH**：对资源进行部分修改。

### HTTP 状态码
- **1xx**：信息性状态码，表示请求已被接收，继续处理。
- **2xx**：成功状态码，表示请求已成功被服务器接收、理解、并接受。
  - 200 OK：请求成功。
  - 201 Created：资源创建成功。
- **3xx**：重定向状态码，表示需要进一步操作以完成请求。
  - 301 Moved Permanently：资源永久移动。
  - 302 Found：资源临时移动。
- **4xx**：客户端错误状态码，表示请求包含语法错误或无法完成。
  - 400 Bad Request：请求无效。
  - 404 Not Found：资源未找到。
- **5xx**：服务器错误状态码，表示服务器未能完成有效的请求。
  - 500 Internal Server Error：服务器内部错误。
  - 503 Service Unavailable：服务不可用。

### HTTP 头部字段
- **通用头部**：如 `Cache-Control`、`Connection`。
- **请求头部**：如 `User-Agent`、`Accept`。
- **响应头部**：如 `Server`、`Content-Type`。
- **实体头部**：如 `Content-Length`、`Content-Encoding`。

### HTTP 版本
- **HTTP/1.0**：每个请求/响应都会建立一个新的连接。
- **HTTP/1.1**：引入了持久连接、管道化、分块传输编码等特性。
- **HTTP/2**：引入了二进制帧、多路复用、头部压缩等特性，提升了性能。
- **HTTP/3**：基于QUIC协议，进一步优化了传输效率和安全性。

### HTTPS
HTTPS 是 HTTP 的安全版本，通过 SSL/TLS 协议对数据进行加密，确保数据传输的安全性。

### 示例
一个简单的 HTTP 请求和响应示例：

**请求：**
```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

**响应：**
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<html>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```

HTTP 是互联网的基础协议之一，理解其工作原理对于开发和维护网络应用至关重要。

## TCP 三次握手
TCP（传输控制协议）的三次握手是建立网络连接的一个过程，它确保了数据能够可靠地在客户端和服务器之间传输。这个过程涉及三个步骤，因此被称为“三次握手”。以下是三次握手的详细过程：

1. **第一次握手 - SYN**：
   - 客户端想要与服务器建立连接，于是发送一个特殊的TCP段，称为SYN（同步序列编号）段。
   - 这个SYN段包含一个随机生成的序列号（例如，序列号 = X），该序列号用于跟踪通信的顺序。
   - 此时客户端进入SYN_SENT状态，等待服务器确认。

2. **第二次握手 - SYN-ACK**：
   - 服务器接收到客户端的SYN段后，会发送回一个SYN-ACK段作为响应。
   - 这个SYN-ACK段包含两个部分：一个是服务器自己的SYN段，包含服务器随机生成的序列号（例如，序列号 = Y）；另一个是对客户端SYN段的确认（ACK = X + 1）。
   - 服务器在发送SYN-ACK段后进入SYN_RECEIVED状态。

3. **第三次握手 - ACK**：
   - 客户端接收到服务器的SYN-ACK段后，会发送一个ACK段（确认段）给服务器。
   - 这个ACK段包含对服务器SYN段的确认（ACK = Y + 1）。
   - 一旦这个ACK段到达服务器，客户端和服务器都进入ESTABLISHED状态，此时TCP连接已经成功建立，双方可以开始数据传输。

三次握手的目的在于确保双方都准备好进行通信，并且双方都同意初始序列号。这个过程也防止了旧的重复连接初始化造成的混乱问题。通过这种方式，TCP协议提供了一个可靠的数据传输服务。

## http2和http1区别

## websocket原理
WebSocket 是一种网络通信协议，它提供了全双工通信功能，允许数据在客户端和服务器之间双向流动。与传统的 HTTP 请求-响应模式不同，WebSocket 建立的是一个持久的连接，使得数据可以实时地在客户端和服务器之间传输，非常适合需要实时交互的应用场景，如在线聊天、游戏、实时通知等。

WebSocket 的工作原理如下：

1. **握手阶段**：
   - WebSocket 连接始于一个特殊的 HTTP 请求，称为“握手”请求。客户端发送一个包含 `Upgrade: websocket` 和 `Connection: Upgrade` 头部的 HTTP 请求，以及一个 `Sec-WebSocket-Key` 随机生成的密钥。
   - 服务器接收到这个请求后，如果支持 WebSocket，它会返回一个 HTTP 101 状态码（Switching Protocols）的响应，包含 `Sec-WebSocket-Accept` 头部，这个头部是通过客户端发送的密钥与一个固定的 GUID 字符串进行 SHA-1 哈希然后 Base64 编码得到的。
   - 握手成功后，连接就从 HTTP 协议升级到了 WebSocket 协议。

2. **数据传输**：
   - 一旦 WebSocket 连接建立，客户端和服务器就可以通过这个连接发送数据帧（frames）。这些数据帧可以是文本、二进制数据或控制帧（如关闭帧、ping/pong 帧等）。
   - 数据帧的传输是全双工的，意味着客户端和服务器可以同时发送和接收数据。
   - WebSocket 协议定义了如何将消息分割成帧、如何将帧组装成消息、以及如何处理错误和关闭连接。

3. **连接维持**：
   - WebSocket 连接是持久的，除非客户端或服务器明确地关闭连接，或者网络中断导致连接丢失。
   - 为了维持连接，WebSocket 协议定义了 ping/pong 机制，用于检测连接是否仍然活跃。一方可以发送一个 ping 帧，另一方应该回复一个 pong 帧作为响应。

4. **关闭连接**：
   - 当客户端或服务器想要关闭连接时，可以发送一个关闭帧（close frame），另一方收到关闭帧后，也会回复一个关闭帧，然后连接就会关闭。
   - 关闭帧可以包含一个状态码和原因短语，说明关闭的原因。

WebSocket 协议的主要优点是它减少了不必要的网络流量和延迟，因为不需要为每个消息都建立和关闭连接。此外，WebSocket 协议支持跨域通信，可以在不同的域名之间建立连接。

## 网络底层连接
linux 下一切皆文件, 判断文件是否还有数据可读, 有一个专门的错误
EOF, end of file. 所以一个tcp连接判断是否关闭可以eof, 出现了这个错误. 就说明了对方已经关闭连接了