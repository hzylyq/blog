## es 的插入和查询流程
Elasticsearch（简称 ES）是一个分布式搜索和分析引擎，基于 Apache Lucene 构建。ES 的查询流程涉及多个步骤，从客户端发起请求到最终返回结果，整个过程是分布式的、高效的。以下是 ES 查询的详细流程：

---

### 1. **客户端发起查询请求**
客户端向 ES 集群发送查询请求，请求可以发送到任意一个节点（协调节点）。

- 请求通常以 RESTful API 的形式发送，例如：
  ```bash
  GET /my_index/_search
  {
    "query": {
      "match": {
        "field": "value"
      }
    }
  }
  ```

---

### 2. **请求到达协调节点**
ES 集群中的任意一个节点都可以作为协调节点（Coordinating Node），负责接收客户端的请求并协调查询过程。

- 协调节点的主要职责：
  - 解析查询请求。
  - 确定需要查询的索引和分片。
  - 将查询请求分发到相关分片。
  - 收集分片的查询结果并返回给客户端。

---

### 3. **确定目标分片**
ES 的索引由多个分片（Shard）组成，每个分片是一个独立的 Lucene 索引。协调节点根据查询请求确定需要查询的分片。

- **分片类型**：
  - **主分片（Primary Shard）**：负责数据的写入和读取。
  - **副本分片（Replica Shard）**：主分片的副本，用于提高查询性能和容错性。

- **分片选择**：
  - 默认情况下，ES 会轮询选择主分片或副本分片来执行查询，以实现负载均衡。

---

### 4. **分发查询请求**
协调节点将查询请求分发到目标分片所在的节点（数据节点）。

- 每个分片会独立执行查询，并返回局部结果。

---

### 5. **分片执行查询**
每个分片在自己的 Lucene 索引上执行查询。

- **查询阶段**：
  - **Query Phase**：分片根据查询条件从 Lucene 索引中检索匹配的文档，并计算文档的相关性得分。
  - **Fetch Phase**：根据 Query Phase 的结果，获取文档的详细内容（如字段值）。

---

### 6. **合并结果**
协调节点收集所有分片的查询结果，并进行合并和排序。

- **排序**：根据文档的相关性得分（`_score`）或其他指定字段进行排序。
- **分页**：如果查询请求中包含分页参数（如 `from` 和 `size`），协调节点会根据分页参数截取结果。

---

### 7. **返回结果**
协调节点将最终的查询结果返回给客户端。

- 返回的结果通常包括：
  - 匹配的文档列表。
  - 文档的相关性得分。
  - 查询的总命中数（`total`）。
  - 分页信息。

示例返回结果：
```json
{
  "took": 10,
  "timed_out": false,
  "_shards": {
    "total": 5,
    "successful": 5,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total": {
      "value": 100,
      "relation": "eq"
    },
    "max_score": 1.0,
    "hits": [
      {
        "_index": "my_index",
        "_type": "_doc",
        "_id": "1",
        "_score": 1.0,
        "_source": {
          "field": "value"
        }
      }
    ]
  }
}
```

---

### 8. **查询优化**
ES 在查询过程中会进行多种优化，以提高查询性能：

- **缓存**：
  - **Query Cache**：缓存查询结果。
  - **Request Cache**：缓存整个查询请求的结果。
  - **Field Data Cache**：缓存字段数据，用于排序和聚合。

- **分布式搜索**：
  - 查询请求会被并行分发到多个分片，充分利用集群的计算能力。

- **分页优化**：
  - 使用 `search_after` 或 `scroll` 代替传统的 `from` 和 `size`，避免深度分页的性能问题。

---

### 9. **查询类型**
ES 支持多种查询类型，常见的包括：

- **全文检索**：
  - `match`：匹配文本字段。
  - `match_phrase`：匹配短语。
  - `multi_match`：多字段匹配。

- **精确查询**：
  - `term`：精确匹配某个字段。
  - `terms`：匹配多个值。
  - `range`：范围查询。

- **复合查询**：
  - `bool`：组合多个查询条件（`must`、`should`、`must_not`、`filter`）。
  - `constant_score`：将查询包装为常量得分。

- **聚合查询**：
  - `terms`：按字段分组统计。
  - `avg`、`sum`、`min`、`max`：计算聚合值。

---

### 10. **查询性能优化建议**
- **合理设计索引**：
  - 根据业务需求设计索引和分片数量。
  - 避免单个索引过大或分片过多。

- **使用过滤器**：
  - 使用 `filter` 代替 `query`，避免计算相关性得分。

- **减少返回字段**：
  - 使用 `_source` 过滤，只返回需要的字段。

- **避免深度分页**：
  - 使用 `search_after` 或 `scroll` 代替 `from` 和 `size`。

- **启用缓存**：
  - 根据需求启用 Query Cache 或 Request Cache。

---

### 总结
ES 的查询流程是一个分布式的、高效的过程，涉及多个节点的协作。通过理解查询流程和优化方法，可以更好地利用 ES 的强大搜索和分析能力。




## keyword和text的区别
在 Elasticsearch 中，`keyword` 和 `text` 是两种常用的字段类型，它们的主要区别在于数据的存储方式、分词处理以及适用场景。以下是它们的详细对比：

---

### 1. **`text` 类型**
`text` 类型用于存储全文搜索的文本数据，例如文章内容、描述等。

#### 特点
- **分词处理**：
  - `text` 类型的字段会被分词器（Analyzer）拆分为多个词项（Terms），以便支持全文搜索。
  - 默认使用标准分词器（Standard Analyzer），将文本按空格和标点符号拆分，并转换为小写。
  - 例如，字符串 `"Hello World!"` 会被分词为 `["hello", "world"]`。

- **全文搜索**：
  - 支持模糊搜索、短语搜索、相关性评分等高级搜索功能。
  - 适合用于需要匹配部分内容的场景。

- **不用于排序和聚合**：
  - 由于 `text` 字段被分词，通常不直接用于排序或聚合操作。如果需要排序或聚合，可以使用 `fields` 多字段特性，同时定义一个 `keyword` 子字段。

#### 示例
```json
{
  "mappings": {
    "properties": {
      "content": {
        "type": "text"
      }
    }
  }
}
```

---

### 2. **`keyword` 类型**
`keyword` 类型用于存储精确值的字符串数据，例如 ID、标签、状态等。

#### 特点
- **不分词**：
  - `keyword` 类型的字段不会被分词，而是作为一个完整的字符串存储。
  - 例如，字符串 `"Hello World!"` 会作为一个整体存储。

- **精确匹配**：
  - 支持精确匹配查询（如 `term` 查询）。
  - 适合用于需要完全匹配的场景，例如过滤、排序、聚合等。

- **排序和聚合**：
  - 由于 `keyword` 字段是完整的字符串，可以直接用于排序和聚合操作。

#### 示例
```json
{
  "mappings": {
    "properties": {
      "status": {
        "type": "keyword"
      }
    }
  }
}
```

---

### 3. **`text` 和 `keyword` 的区别对比**

| 特性                | `text` 类型                          | `keyword` 类型                     |
|---------------------|--------------------------------------|-------------------------------------|
| **分词处理**         | 是                                   | 否                                  |
| **存储方式**         | 分词后存储为多个词项                 | 作为一个完整的字符串存储            |
| **适用场景**         | 全文搜索                             | 精确匹配、过滤、排序、聚合          |
| **查询类型**         | 支持全文搜索（如 `match` 查询）      | 支持精确查询（如 `term` 查询）      |
| **排序和聚合**       | 不支持直接排序和聚合                 | 支持直接排序和聚合                  |
| **示例数据**         | `"Hello World!"` → `["hello", "world"]` | `"Hello World!"` → `"Hello World!"` |

---

### 4. **多字段特性（`fields`）**
在实际使用中，一个字段可能同时需要支持全文搜索和精确匹配。ES 提供了多字段特性（`fields`），允许为一个字段同时定义 `text` 和 `keyword` 类型。

#### 示例
```json
{
  "mappings": {
    "properties": {
      "message": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      }
    }
  }
}
```

- **`message` 字段**：
  - 作为 `text` 类型，支持全文搜索。
- **`message.keyword` 字段**：
  - 作为 `keyword` 类型，支持精确匹配、排序和聚合。

#### 查询示例
- 全文搜索：
  ```json
  {
    "query": {
      "match": {
        "message": "hello world"
      }
    }
  }
  ```
- 精确匹配：
  ```json
  {
    "query": {
      "term": {
        "message.keyword": "Hello World!"
      }
    }
  }
  ```

---

### 5. **如何选择 `text` 和 `keyword`**
- 使用 `text` 类型的场景：
  - 需要全文搜索的字段，例如文章内容、描述等。
  - 不需要排序和聚合的字段。

- 使用 `keyword` 类型的场景：
  - 需要精确匹配的字段，例如 ID、状态码、标签等。
  - 需要排序和聚合的字段。

- 使用多字段特性的场景：
  - 一个字段同时需要支持全文搜索和精确匹配。

---

### 6. **注意事项**
- **存储开销**：
  - `text` 类型由于分词处理，可能会占用更多的存储空间。
  - `keyword` 类型存储完整的字符串，适合较短的文本。

- **性能优化**：
  - 对于不需要分词的字段，尽量使用 `keyword` 类型，避免不必要的分词开销。
  - 对于长文本字段，使用 `text` 类型，并结合 `fields` 定义 `keyword` 子字段。

---

### 总结
- `text` 类型适合全文搜索，支持分词和高级搜索功能。
- `keyword` 类型适合精确匹配、排序和聚合。
- 通过多字段特性（`fields`），可以同时支持 `text` 和 `keyword` 的需求。

根据实际业务场景选择合适的字段类型，可以有效提高 ES 的性能和查询效率。